(Finds the median in a list of odd numbers)
(The numbers are in unary, as "a"s, separated by "b"s)
(Eg: bbaaaababa = [0,0,4,1,1]

0 -> start

#define goto-first symbol name return-state majority-direction fixing-direction
{name}:
    read {symbol}:
        move {fixing-direction}
        {return-state}
    else -> move {majority-direction}
#enifed

start(*) -> move left
            add-first-b

add-first-b(*) -> write b
                  move right
                  compare-cycle

{goto-first _ left-to-compare-cycle right-then-compare-cycle left right}
right-then-compare-cycle(*) -> move right
                               compare-cycle
compare-cycle: Assumes we are on the first block, after the first "b". (Potentially on a "b")
    read a: Need to match it with another a.
        write A
        move right
        match-next-a-after-b
    read A -> move right
    read b -> in-order
    read _ -> move left
              start-eliminating
    else -> ERROR-compare-cycle (remember to change in submission)

match-next-a-after-b:
    read a -> move right
    read A -> move right
    read b -> move right
              match-next-a-have-seen-b
    read _ -> move left
              start-eliminating
    else -> ERROR-match-next-a-after-b (remember to change in submission)

match-next-a-have-seen-b:
    read a -> write A
              move-to-last-bx-to-compare-again
    read A -> move right
    read b: First block is longer
        first-block-is-longer
    read _: Happens when we end in a "b"
        first-block-is-longer
    else -> ERROR-match-next-a-have-seen-b (remember to change in submission)

move-to-last-bx-to-compare-again: Assumes we are on the last swapped character on the right block.
    read b -> move left
              move-to-last-bx-then-compare
    else -> move left
    read _ -> ERROR-move-to-last-bx-to-compare-again (remember to change in submission)

move-to-last-bx-then-compare:
    read b -> move right
              compare-cycle
    read x -> move right
              compare-cycle
    else -> move left
    read _ -> ERROR-move-to-last-bx-then-compare (remember to change in submission)

first-block-is-longer -> move left
                         swap-last-b-to-y

swap-last-b-to-y: Assumes we are on the last character to the right of the "b" we need.
    read b -> write y
              move left
              swap-longest-to-L
    else -> move left
    read _ -> ERROR-swap-last-b-to-y

swap-longest-to-L: Assumes we are on the last character right next of the now "y"
    read A -> write L
              move left
    read a -> write L
              move left
    read x -> move right
              begin-swap-left-right-block
    read b -> move right
              begin-swap-left-right-block
    else -> ERROR-swap-longest-to-L

begin-swap-left-right-block: Assumes we are on the first character to swap.
    read L -> write A (but what if there are no other "A"s? probs deal with it in another state)
              move right
              convert-next-A-to-L
    read A -> move right (unsure of this line tbh)

move-to-last-bx-to-convert-A-to-L:
    read b -> move right
              begin-swap-left-right-block
    read x -> move right
              begin-swap-left-right-block
    else -> move left

convert-next-A-to-L: Assumes we start on the right of the A
    read A:
        write L
        move left
        move-to-last-bx-to-convert-A-to-L
    read b -> swap-last-A-to-L
    read _ -> swap-last-A-to-L
    else -> move right

swap-last-A-to-L:
    read A -> write L
              move-y
    else -> move left

move-y -> move-y-fix-current
move-y-fix-current: Assumes we are on the position the "y" needs to go, and that the next "y" should be an L
    read L -> write y
              move right
              move-y-fix-next-y
    else -> error!

move-y-fix-next-y:
    read y -> write L
              clean-string
    else -> move right

{goto-first _ left-to-clean start-cleaning left right}
clean-string -> left-to-clean
start-cleaning:
    read A -> write a
              move right
    read L -> write a
              move right
    read y -> write b
              move right
    read x -> write b
              move right
    read _ -> reject!
    read b -> move right
    read a -> move right
    read _ -> move left
              left-to-compare-cycle

{goto-first _ left-to-clean-but-stop-at-x-coming-back start-cleaning-btaxcb left right}
start-cleaning-btaxcb:
    read A -> write a
              move right
    read y -> write b
              move right
    read x -> move right
    read L -> write a
              move right
    read _ -> reject!
    read b -> move right
    read a -> move right
    read _ -> move left
              move-left-until-x

move-left-until-x:
    read x -> move right
              compare-cycle
    else -> move left

in-order:
    read b -> write x
    else -> left-to-clean-but-stop-at-x-coming-back

start-eliminating: Assumes we are on the last character
    read A -> write a
              move left
    read x -> write b
              move left
    read _ -> move right
              remove-first-b
    else -> move left

remove-first-b: Assumes we are on the first character, which is a "b"
    read b -> write _
              move right
              check-if-pair-needs-to-be-removed

{goto-first _ left-to-check-pairs check-if-pair-needs-to-be-removed left right}
check-if-pair-needs-to-be-removed: Assume we are on the first character.
    read b -> left-to-remove-pair
    read _ -> accept!
    else -> move right

{goto-first _ left-to-remove-pair remove-pair left right}
remove-pair -> remove-first-block
remove-first-block: Assume we are on the first character
    read a -> write _
              move right
    read b -> write _
              move right
              right-to-remove-second-block

{goto-first _ right-to-remove-second-block remove-second-block right left}
remove-second-block: Assume we are on the last character
    read a -> write _
              move left
    read b -> write _
              move left
              left-to-check-pairs
